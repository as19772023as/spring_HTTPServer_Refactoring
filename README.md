## «1.1. HTTP и современный Web»

### Refactoring & MultiThreading

#### Легенда

Достаточно часто после того, как прототип проверен (речь о том, что было реализовано на лекции), возникает задача — привести это в должный вид: выделить класс Server c методами, обеспечить нужную функциональность.

ЗАДАЧА 1

Необходимо отрефакторить код, рассмотренный на лекции, и применить все знания, которые у вас есть:

1. Выделить класс Server с методами для: 
   - запуска; 
   - обработки конкретного подключения.
  
2. Реализовать обработку подключений с помощью ThreadPool — выделите фиксированный на 64 потока, и каждое подключение обрабатывайте в потоке из пула.

ЗАДАЧА 2

### Handlers*

#### Легенда

Сервер, который вы написали в предыдущей задаче, пока не расширяемый, и его нельзя переиспользовать, т. к. код 
обработки зашит прямо внутрь сервера.

Попробуйте сделать его полезнее — чтобы в сервер можно было добавлять обработчиков на определённые шаблоны 
путей.

public class Main {
    public static void main(String[] args){
      final var server = new Server();  
      // код инициализации сервера (из вашего предыдущего ДЗ)

      // добавление хендлеров (обработчиков)    
      server.addHandler("GET", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });
      server.addHandler("POST", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });

      server.listen(9999);
    }    
}
- В итоге на запрос типа GET на путь "/messages" будет вызван первый обработчик, а на запрос типа POST и путь "/messages" будет вызван второй.
  
### Query

#### Легенда

В рамках изучения Java Core и работы протокола HTTP вы использовали библиотеку HttpClient из состава Apache HttpComponents.

В состав этой библиотеки входит утилитный класс URLEncodedUtils, который и позволяет «парсить» Query String, извлекая параметры.

Необходимо добавить в ваш сервер из предыдущего ДЗ функциональность обработки параметров запроса так, чтобы можно было из объекта типа Request отдельно получать и путь запроса, и параметры из Query String.

Например, это можно сделать в виде метода getQueryParam(String name) и getQueryParams(). Подумайте, что они должны возвращать, исходя из документации на утилитный класс.

- Задача
1. Подключите к своему проекту HttpClient.
2. Реализуйте функциональность по обработке параметров из Query.
3. При необходимости доработайте функциональность поиска хендлера так, чтобы учитывался только путь без Query, 
   т. е. хендлер, зарегистрированный на "/messages", обрабатывал и запросы "/messages?last=10".

**Реализуйте новую функциональность в ветке feature/query**

### x-www-form-urlencoded*

#### Легенда

Необходимо добавить в ваш сервер из предыдущего домашнего задания функциональность обработки тела, 
оформленного в виде x-www-form-url-encoded запроса так, чтобы можно было из объекта типа Request отдельно 
получать параметры, переданные в теле запроса.

**Реализуйте новую функциональность в ветке feature/form**

### multipart/form-data*

#### Легенда

Реализуйте полную функциональность и добавьте поддержку multipart-запросов. Используйте для этого библиотеку FileUpload.
- в передаваемой вам форме может быть два параметра с одинаковым именем;
- каждый Part может быть как файлом, так и обычным полем.
Это значит, что нужно уметь отличать обычные поля от файлов.

**Реализуйте новую функциональность в ветке feature/multipart**